{-# OPTIONS_GHC -XFlexibleInstances -XTypeSynonymInstances #-}
module Level where

import Data.Array

-- Model
type Rect = (Int, Int, Int, Int)
type Pos = (Int, Int)

data Level = Level [Map]

data Map = Map { mapName :: String, mapTiles :: Array Pos Char,
                 mapObjs :: [(Obj, ObjPos)], mapRegions :: [(Region, Rect)],
                 mapFlags :: [MapFlag], mapRandomPlaces :: [Pos],
                 mapRandomObjs :: [Char], mapRandomMons :: [Char],
                 mapContainer :: Maybe (Obj, ObjPos) }
           -- | InitMap String Char Char Char Bool Bool Unknown Bool

initMap = Map { mapName = "test",
                mapTiles = listArray ((0, 0), (79, 21)) (repeat ' '),
                mapObjs = [], mapRegions = [], mapFlags = [],
                mapRandomPlaces = [], mapRandomObjs = [],
                mapRandomMons = [], mapContainer = Nothing }

data Rand a = Random | Fixed a

data MapFlag = NoTeleport | HardFloor
data Region = Region (Rand Lighting) RegionType (Maybe (Fill, Maybe Bool))
              | NonDiggable -- | Branch Unknown
data Lighting = Lit | Unlit
data Fill = Filled | Unfilled
data RegionType = Ordinary | Morgue | Barracks | Throne

data ObjPos = ObjPos Pos | RandomPos | RandomPosIndex Int | Contained
data Obj = Obj ObjSym (Rand String)
               (Maybe (Rand Blessing, Maybe (Spe, Maybe String)))
           | Monst MonstSym (Rand String) [Behaviour]
           | Trap (Rand TrapType) | Fountain
           | Stair StairDir | Engraving Ink String
           | Door (Rand DoorType) | Drawbridge Dir (Rand DoorType)
objCtor (Obj _ _ _)      = 0
objCtor (Monst _ _ _)    = 1
objCtor (Trap _)         = 2
objCtor Fountain         = 3
objCtor (Stair _)        = 4
objCtor (Engraving _ _)  = 5
objCtor (Door _)         = 6
objCtor (Drawbridge _ _) = 7
objCtorCount = 8
-- WTF levregion
data ObjSym = ObjChar Char | RandomObj | RandomObjIndex Int
type Spe = Int
data MonstSym = MonstChar Char | RandomMonst | RandomMonstIndex Int
data Blessing = Blessed | Uncursed | Cursed
data Behaviour = Hostile | Peaceful | Asleep
data TrapType = TrapDoor | Pit
data StairDir = UpStair | DownStair
data Ink = Burn | Blood
data Dir = North | East | South | West
data DoorType = Open | Closed | Locked

mapSize (Map { mapTiles = ts }) = let (_, (x, y)) = bounds ts
                                  in (x + 1, y + 1)

class Save a where
    load :: String -> a
    save :: a -> ShowS

commas :: (a -> ShowS) -> [a] -> ShowS
commas f (x:xs) = foldl (\ss y -> ss . comma . f y) (f x) xs
commas f []     = id

comma = showString ", "
newline = showString "\n"

instance Save Level where
    save (Level ms) = foldl (\ss m -> ss . save m)
                            ("# Generated by level editor\n\n" ++) ms

instance Save Map where
    save mp = showString "MAZE: " . save (mapName mp)
              . (if null (mapFlags mp) then id else
                 showString ",' '\nFLAGS: " . commas save (mapFlags mp))
              . showString "\nGEOMETRY: center,center"
              . ("\nMAP\n" ++) . (showTiles (mapSize mp) (mapTiles mp) ++)
              . showString "ENDMAP\n"
              . permute "RANDOM_PLACES: " mapRandomPlaces
              . permute "RANDOM_MONSTERS: " mapRandomMons
              . permute "RANDOM_OBJECTS: " mapRandomObjs
              . maybe id (\(o, p) -> ("CONTAINER: " ++)) (mapContainer mp)
              . foldl (\ss o -> ss . save o) (showString "# Objects\n")
                      (concat sortedObjs)
      where
        -- Unfortunately `elems` is top-to-bottom, left-to-right
        showTiles (w, h) ts = go (0, 0)
          where
            go (x, y) | x < w && y < h = ts ! (x, y) : go (x+1, y)
                      | y < h          = '\n' : go (0, y+1)
                      | otherwise      = []

        permute nm f | null (f mp) = id
                     | otherwise   = showString nm . commas save (f mp)
                                     . newline

        sortedObjs = foldr sortObj (replicate objCtorCount []) (mapObjs mp)
        sortObj o accum = let (bef, (os:aft)) = splitAt (objCtor (fst o)) accum
                          in bef ++ [o:os] ++ aft

instance Save (Obj, ObjPos) where
    save (o, p) = case o of
      Obj sym nm _     -> showString "OBJECT: " . save sym . comma . save nm
                          . comma . save p . newline-- TODO
      Monst sym nm bh  -> showString "MONSTER: " . save sym . comma . save nm
                          . comma . save p . comma . commas save bh
      Trap typ         -> showString "TRAP: " . save typ . q
      Fountain         -> showString "FOUNTAIN: " . save p . newline
      Stair dir        -> showString "STAIR: " . save dir . q
      Engraving ink s  -> ("ENGRAVING: " ++) . save ink . comma . save s . q
      Door typ         -> showString "DOOR: " . save typ . q
      Drawbridge dir t -> ("DRAWBRIDGE: " ++) . save dir . comma . save t . q
     where q = comma . save p . newline

instance Save ObjPos where
    save (ObjPos p)         = save p
    save RandomPos          = showString "random"
    save (RandomPosIndex i) = showString "places[" . shows i . (']':)
    save Contained          = showString "contained"

instance Save ObjSym where
    save (ObjChar c)        = save c
    save RandomObj          = showString "random"
    save (RandomObjIndex i) = showString "objects[" . shows i . (']':)

instance Save MonstSym where
    save (MonstChar c) = save c
    save RandomMonst  = showString "random"
    save (RandomMonstIndex i) = showString "monsters[" . shows i . (']':)

instance Save Blessing where
    save b = let s = case b of Blessed  -> "blessed"
                               Uncursed -> "uncursed"
                               Cursed   -> "cursed"   in showString s

instance Save Behaviour where
    save b = let s = case b of Hostile  -> "hostile"
                               Peaceful -> "peaceful"
                               Asleep   -> "asleep"   in showString s

instance Save TrapType where
    save t = let s = case t of TrapDoor -> "trapdoor"
                               Pit      -> "pit"      in showString s

instance Save StairDir where
    save t = let s = case t of UpStair   -> "up"
                               DownStair -> "down" in showString s

instance Save Ink where
    save i = let s = case i of Burn  -> "burn"
                               Blood -> "blood" in showString s

instance Save Dir where
    save d = let s = case d of North -> "north"
                               South -> "south"
                               East  -> "east"
                               West  -> "west"  in showString s

instance Save DoorType where
    save d = let s = case d of Open   -> "open"
                               Closed -> "closed"
                               Locked -> "locked" in showString s

-- TODO: Not sure if the escaping convention is the same...
instance Save Pos where save = shows
instance Save Rect where save = shows
instance Save String where save = shows
instance Save Char where save = shows

instance Save a => Save (Rand a) where
    save Random    = showString "random"
    save (Fixed x) = save x

instance Save MapFlag where
    save NoTeleport = showString "noteleport"
    save HardFloor  = showString "hardfloor"

-- vi: set sw=4 ts=4 sts=4 tw=79 ai et nocindent:
