{-# OPTIONS_GHC -XFlexibleInstances -XTypeSynonymInstances #-}
module Level where

import Data.Array
import qualified Data.Map as Map
import Data.Map (Map)

-- Model
type Rect = (Int, Int, Int, Int)
type Pos = (Int, Int)

data Level = Level { levelName :: String, levelTiles :: Array Pos Char,
                     prevLevels, nextLevels :: [Level],
                     levelObjs :: Map ObjPos [Obj],
                     levelRegions :: [(Region, Rect)],
                     levelFlags :: [LevelFlag], levelRandomPlaces :: [Pos],
                     levelRandomObjs, levelRandomMons :: [Char],
                     levelContainer :: Maybe (Obj, ObjPos) }

initLevel = Level { levelName = "untitled",
                    levelTiles = listArray ((0, 0), (79, 21)) (repeat ' '),
                    prevLevels = [], nextLevels = [],
                    levelObjs = Map.empty, levelRegions = [], levelFlags = [],
                    levelRandomPlaces = [], levelRandomObjs = [],
                    levelRandomMons = [], levelContainer = Nothing }

data Rand a = Random | Fixed a

data LevelFlag = NoTeleport | HardFloor
data Region = Region (Rand Lighting) RegionType (Maybe (Fill, Maybe Bool))
              | NonDiggable -- | Branch Unknown
data Lighting = Lit | Unlit
data Fill = Filled | Unfilled
data RegionType = Ordinary | Morgue | Barracks | Throne

data ObjPos = ObjPos Pos | RandomPos | RandomPosIndex Int | Contained
              deriving (Eq, Ord)
data Obj = Obj ObjSym (Rand String)
               (Maybe (Rand Blessing, Maybe (Spe, Maybe String)))
           | Monst MonstSym (Rand String) [Behaviour]
           | Trap (Rand TrapType) | Fountain
           | Stair StairDir | Engraving Ink String
           | Door (Rand DoorType) | Drawbridge Dir (Rand DoorType)
objCtor (Obj _ _ _)      = 0
objCtor (Monst _ _ _)    = 1
objCtor (Trap _)         = 2
objCtor Fountain         = 3
objCtor (Stair _)        = 4
objCtor (Engraving _ _)  = 5
objCtor (Door _)         = 6
objCtor (Drawbridge _ _) = 7
objCtorCount = 8

objChar (Obj ch _ _)    = case ch of ObjChar c -> c; otherwise -> 'R'
objChar (Monst sym _ _) = case sym of MonstChar c -> c; otherwise -> 'M'
objChar (Stair dir)     = case dir of UpStair -> '<'; DownStair -> '>'
objChar o               = "  ^{ ~++" !! objCtor o

-- WTF levregion
data ObjSym = ObjChar Char | RandomObj | RandomObjIndex Int
type Spe = Int
data MonstSym = MonstChar Char | RandomMonst | RandomMonstIndex Int
data Blessing = Blessed | Uncursed | Cursed
data Behaviour = Hostile | Peaceful | Asleep
data TrapType = TrapDoor | Pit
data StairDir = UpStair | DownStair
data Ink = Burn | Blood
data Dir = North | East | South | West
data DoorType = Open | Closed | Locked

levelSize (Level { levelTiles = ts }) = let (_, (x, y)) = bounds ts
                                        in (x + 1, y + 1)

class Save a where
    load :: String -> a
    save :: a -> ShowS

commas :: (a -> ShowS) -> [a] -> ShowS
commas f (x:xs) = foldl (\ss y -> ss . comma . f y) (f x) xs
commas f []     = id

comma = showString ", "
newline = showString "\n"

saveLevels :: Level -> String
saveLevels l = let ls = reverse (prevLevels l) ++ [l] ++ nextLevels l
               in foldl (\ss l -> ss . save l)
                        ("# Generated by level editor\n\n" ++) ls ""

instance Save Level where
    save lv = showString "MAZE: " . save (levelName lv)
              . (if null (levelFlags lv) then id else
                 showString ",' '\nFLAGS: " . commas save (levelFlags lv))
              . showString "\nGEOMETRY: center,center"
              . ("\nMAP\n" ++) . (showTiles (levelSize lv) (levelTiles lv) ++)
              . showString "ENDMAP\n"
              . permute "RANDOM_PLACES: " levelRandomPlaces
              . permute "RANDOM_MONSTERS: " levelRandomMons
              . permute "RANDOM_OBJECTS: " levelRandomObjs
              . maybe id (\(o, p) -> ("CONTAINER: " ++)) (levelContainer lv)
              . foldl (\ss o -> ss . save o) (showString "# Objects\n")
                      (concat sortedObjs)
      where
        -- Unfortunately `elems` is top-to-bottom, left-to-right
        showTiles (w, h) ts = go (0, 0)
          where
            go (x, y) | x < w && y < h = ts ! (x, y) : go (x+1, y)
                      | y < h          = '\n' : go (0, y+1)
                      | otherwise      = []

        permute nm f | null (f lv) = id
                     | otherwise   = showString nm . commas save (f lv)
                                     . newline

        sortedObjs = let os = concat [map ((,) p) ol
                                      | (p, ol) <- Map.assocs (levelObjs lv)]
                     in foldr sortObj (replicate objCtorCount []) os
        sortObj o accum = let (bef, (os:aft)) = splitAt (objCtor (snd o)) accum
                          in bef ++ [o:os] ++ aft

instance Save (ObjPos, Obj) where
    save (p, o) = case o of
      Obj sym nm _     -> showString "OBJECT: " . save sym . comma . save nm
                          . comma . save p . newline-- TODO
      Monst sym nm bh  -> showString "MONSTER: " . save sym . comma . save nm
                          . comma . save p . comma . commas save bh
      Trap typ         -> showString "TRAP: " . save typ . q
      Fountain         -> showString "FOUNTAIN: " . save p . newline
      Stair dir        -> showString "STAIR: " . save dir . q
      Engraving ink s  -> ("ENGRAVING: " ++) . save ink . comma . save s . q
      Door typ         -> showString "DOOR: " . save typ . q
      Drawbridge dir t -> ("DRAWBRIDGE: " ++) . save dir . comma . save t . q
     where q = comma . save p . newline

instance Save ObjPos where
    save (ObjPos p)         = save p
    save RandomPos          = showString "random"
    save (RandomPosIndex i) = showString "places[" . shows i . (']':)
    save Contained          = showString "contained"

instance Save ObjSym where
    save (ObjChar c)        = save c
    save RandomObj          = showString "random"
    save (RandomObjIndex i) = showString "objects[" . shows i . (']':)

instance Save MonstSym where
    save (MonstChar c) = save c
    save RandomMonst  = showString "random"
    save (RandomMonstIndex i) = showString "monsters[" . shows i . (']':)

instance Save Blessing where
    save b = let s = case b of Blessed  -> "blessed"
                               Uncursed -> "uncursed"
                               Cursed   -> "cursed"   in showString s

instance Save Behaviour where
    save b = let s = case b of Hostile  -> "hostile"
                               Peaceful -> "peaceful"
                               Asleep   -> "asleep"   in showString s

instance Save TrapType where
    save t = let s = case t of TrapDoor -> "trapdoor"
                               Pit      -> "pit"      in showString s

instance Save StairDir where
    save t = let s = case t of UpStair   -> "up"
                               DownStair -> "down" in showString s

instance Save Ink where
    save i = let s = case i of Burn  -> "burn"
                               Blood -> "blood" in showString s

instance Save Dir where
    save d = let s = case d of North -> "north"
                               South -> "south"
                               East  -> "east"
                               West  -> "west"  in showString s

instance Save DoorType where
    save d = let s = case d of Open   -> "open"
                               Closed -> "closed"
                               Locked -> "locked" in showString s

-- TODO: Not sure if the escaping convention is the same...
instance Save Pos where save = shows
instance Save Rect where save = shows
instance Save String where save = shows
instance Save Char where save = shows

instance Save a => Save (Rand a) where
    save Random    = showString "random"
    save (Fixed x) = save x

instance Save LevelFlag where
    save NoTeleport = showString "noteleport"
    save HardFloor  = showString "hardfloor"

-- vi: set sw=4 ts=4 sts=4 tw=79 ai et nocindent:
